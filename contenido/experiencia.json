{
  "projects": [
    {
      "id": "cypher-vault",
      "title": "Aplicacion: Cypher Vault",
      "media": [
        {
          "type": "video",
          "src": "https://gitlab.com/spectrelonewolf/pp-tpfinal/-/raw/main/Entrega%20Final/Manual%20de%20usuario/Cypher%20Vault%20-%20Demo%20%E2%80%91%20Final.mp4?ref_type=heads",
          "active": true
        },
        {
          "type": "video",
          "src": "https://gitlab.com/spectrelonewolf/pp-tpfinal/-/raw/main/Entrega%20Final/Manual%20de%20usuario/Cypher%20Vault%20-%20Promo.mp4?ref_type=heads",
          "active": false
        }
      ],
      "tools": [
        {
          "name": "Android Studio",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Kotlin",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        },
        {
          "name": "Photoshop",
          "icon": "bi-brush"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "El objetivo de este trabajo práctico es que los estudiantes apliquen los conocimientos adquiridos en la asignatura sobre Metodologías Ágiles y Waterfall en el desarrollo de un sistema de autenticación por reconocimiento facial para una Tablet, permitiendo el ingreso a áreas con seguridad."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">El sistema debe ser capaz de capturar imágenes de la cámara frontal de la Tablet.</li><li class=\"list-group-item\">El sistema debe ser capaz de detectar rostros en las imágenes capturadas.</li><li class=\"list-group-item\">El sistema debe ser capaz de identificar a las personas a partir de sus rostros.</li><li class=\"list-group-item\">El sistema debe ser capaz de autenticar a las personas comparando sus rostros con una base de datos de rostros conocidos almacenada en la Tablet.</li><li class=\"list-group-item\">El sistema debe mostrar un mensaje de \"Acceso Permitido\" o \"Acceso Denegado\" en la pantalla de la Tablet en función del resultado de la autenticación.</li><li class=\"list-group-item\">El sistema deberá registrar un log con los datos de ingresos (Hora, ID de persona, etc.).</li><li class=\"list-group-item\">El sistema deberá permitir una alternativa manual de ingreso ante posibles desconexiones (sin Wifi o datos).</li><li class=\"list-group-item\">El sistema deberá permitir el ALTA/MODIFICACIONES de las personas a autenticar.</li><li class=\"list-group-item\">Eficiencia: El sistema debe ser eficiente en el uso de la batería, la memoria y el procesador de la Tablet.</li><li class=\"list-group-item\">Usabilidad: El sistema debe ser fácil de usar para usuarios con diferentes niveles de experiencia en el uso de tabletas.</li><li class=\"list-group-item\">La seguridad y privacidad son preocupaciones importantes cuando se trata del reconocimiento facial en una Tablet. Los fabricantes de dispositivos implementan medidas de seguridad para proteger los datos faciales. Estos datos se almacenan de forma segura en el dispositivo y no se comparten con terceros sin nuestro consentimiento. Además, algunos dispositivos utilizan sensores infrarrojos para garantizar que la captura facial sea auténtica y no una fotografía o una máscara. Sin embargo, es importante recordar que ningún sistema de seguridad es infalible y siempre es recomendable utilizar otras capas de protección como contraseñas adicionales o autenticación de dos factores.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>La última materia de la tecnicatura trata de realizar un proyecto ejecutando la metodología ágil de Scrum. En total, en nuestro equipo éramos seis: un Scrum Master, tres desarrolladores y dos testers. Yo pertenecía al equipo de desarrollo.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Desarrollo de la Aplicación:</strong> La aplicación se implementó en dos meses, cumpliendo ciclos de sprint de 15 días o menos. En cada sprint se nos pedía presentar los avances de la aplicación o incremento.</p><p><strong>2. Idea y Conceptualización:</strong> La aplicación partió de mi idea de armar una galería segura. Debido a que teníamos más integrantes que otros grupos, decidí tomar el requerimiento opcional sobre \"la seguridad de las imágenes almacenadas\".</p><p><strong>3. Implementación de Funcionalidades:</strong> Las imágenes están protegidas mediante verificación por rostro y, en una segunda instancia, autenticación de dos factores (2FA). Además, las imágenes dentro de la galería están cifradas en la base de datos de la aplicación.</p><p><strong>4. Diseño y Usabilidad:</strong> Implementamos el patrón de diseño MVC y decidimos incluir un zócalo de mensajes para facilitar la operatividad al usuario, además de un video tutorial como manual de usuario.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Seguridad de Imágenes:</strong></p><p><strong>Desafío:</strong> Implementar medidas de seguridad adicionales para las imágenes almacenadas.</p><p><strong>Solución:</strong> Cifrar las imágenes dentro de la base de datos y asegurar el acceso mediante verificación por rostro y 2FA.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Trabajo en Equipo y Metodología Ágil:</strong> Aprendí a trabajar de manera efectiva en un equipo utilizando Scrum, lo que nos permitió organizar y presentar los avances de manera periódica.</p><p><strong>Patrones de Diseño:</strong> Implementar el patrón MVC facilitó la separación de responsabilidades y mejoró la mantenibilidad del código.</p><p><strong>Seguridad en Aplicaciones:</strong> La implementación de medidas de seguridad avanzadas, como el cifrado de imágenes y la autenticación multifactor, fue una experiencia valiosa.</p><p><strong>Duración del Proyecto:</strong> El tiempo asignado para completar este proyecto fue de aproximadamente dos meses.</p><p><strong>Resultados y Conclusiones:</strong></p><p><em>El trabajo fue finalizado con su alcance principal planteado, y se sumaron las solicitudes de cambio de nuestro Product Owner. La implementación gráfica y la planificación detallada fueron fundamentales para el éxito del proyecto. En el video tutorial no se muestran todas las funcionalidades debido a limitaciones de tiempo, pero en la presentación en PowerPoint, que se encuentra en el repositorio en la carpeta \"entrega final\", se detallan las funcionalidades adicionales para mejorar la aplicación y posicionarla entre las mejores del mercado.</em></p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/pp-tpfinal/-/tree/main?ref_type=heads"
    },
    {
      "id": "medbot-chatbot",
      "title": "Web : MEDbot con Webauth",
      "media": [
        {
          "type": "video",
          "src": "https://gitlab.com/spectrelonewolf/pp-chatbot/-/raw/main/ChatBot-Tp/20240412/Chatbot%20-%20login%20demo.mp4?ref_type=heads",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Visual Studio Code",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "JavaScript",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Flask",
          "icon": "bi-hdd-network-fill"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        },
        {
          "name": "Photoshop",
          "icon": "bi-brush"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "Después de leer el material e investigar respecto a la aplicación de algoritmos de Machine Learning para Inteligencia Artificial utilizando el lenguaje Python para el procesamiento de los datos crear un sitio el cual aplique los conocimientos adquiridos."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Documentar la investigación de los temas propuestos y subirla a un repositorio de trabajo.</li><li class=\"list-group-item\">Crear un Chatbot.</li><li class=\"list-group-item\">Lograr que el login se realice con reconocimiento de la huella digital en el celular.</li><li class=\"list-group-item\">Optimizar el Chatbot.</li><li class=\"list-group-item\">Entregar la evidencia del repositorio en el que trabajarán.</li><li class=\"list-group-item\">Documentar la Investigación realizada acerca de Aplicación de la IA, Onboarding Digital, Normativas existentes.</li><li class=\"list-group-item\">Definir el objetivo u objetivos que desean lograr con el Chatbot.</li><li class=\"list-group-item\">Herramientas a utilizar.</li><li class=\"list-group-item\">Documentación técnica y funcional del Chatbot.</li><li class=\"list-group-item\">Presentación del desarrollo (Demo).</li><li class=\"list-group-item\">Mejoras detectadas.</li><li class=\"list-group-item\">Documentación final.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>Es un trabajo donde se simulaba la metodología Scrum, pero solo la parte de la entrega por incrementos cada semana. Se nos pidió realizar una app para móvil la cual debía tener WebAuth y un chatbot, con la premisa de que no tenía que instalarse en el dispositivo. Optamos por resolverlo mediante una página web responsive, aprovechando la librería Bootstrap.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Desarrollo de la Aplicación:</strong> Reciclamos un proyecto personal mío de una página web realizada para el hospital Larcade de San Miguel, a la cual le sumamos la funcionalidad de WebAuth y chatbot. Esta página web reciclada era para un prototipo de funcionalidades necesarias para el hospital, requerido por uno de sus médicos pasantes.</p><p><strong>2. Implementación de Funcionalidades:</strong> Utilizamos PyTorch, WebAuth y aplicamos Bootstrap para el diseño de UI. La página almacenaba los chats de los usuarios registrados.</p><p><strong>3. Diseño y Estética:</strong> Me encargué del diseño de la página y su estética en general, además del funcionamiento del backend, el cual tuvo dominio propio (gratuito), es decir, de acceso público.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Integración de WebAuth y Chatbot:</strong></p><p><strong>Desafío:</strong> Integrar las funcionalidades de WebAuth y el chatbot sin que la aplicación necesite instalación en el dispositivo.</p><p><strong>Solución:</strong> Desarrollamos una página web responsive utilizando Bootstrap y almacenamos los chats de los usuarios registrados.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Metodología Scrum:</strong> Aunque solo simulamos la parte de la entrega por incrementos cada semana, aprendí a organizar y presentar los avances de manera periódica.</p><p><strong>Diseño Web y UI:</strong> La experiencia de diseñar y estandarizar la estética de la página fue valiosa, especialmente al usar Bootstrap para una interfaz de usuario responsive.</p><p><strong>Desarrollo Backend:</strong> Montamos el proyecto en versiones Windows y Linux Debian, publicando la página en esta última. Esta experiencia fue crucial para entender el funcionamiento de dominios públicos.</p><p><strong>Duración del Proyecto:</strong> El tiempo asignado para completar este proyecto fue de aproximadamente un mes, con entregas semanales.</p><p><strong>Resultados y Conclusiones:</strong></p><p><strong>Resultados:</strong> El proyecto se completó con éxito, cumpliendo con todos los requerimientos solicitados. Se desarrolló una página web responsive que incluía WebAuth y un chatbot, logrando que la aplicación no necesitara instalación en el dispositivo. La página web reciclada del hospital Larcade fue mejorada significativamente con estas nuevas funcionalidades.</p><p>La página web fue capaz de manejar y almacenar los chats de los usuarios registrados, y la integración de WebAuth añadió una capa adicional de seguridad. La implementación del diseño de UI con Bootstrap hizo que la página fuera accesible y fácil de usar en múltiples dispositivos.</p><p><strong>Conclusiones:</strong> Este proyecto permitió aplicar de manera práctica los conceptos de la metodología Scrum, incluso con una simulación parcial. La experiencia adquirida en el desarrollo de una página web responsive con Bootstrap y la integración de funcionalidades avanzadas como WebAuth y chatbot fue muy valiosa.</p><p>Además, trabajar en equipo bajo una metodología ágil y realizar entregas incrementales nos enseñó a gestionar mejor nuestro tiempo y recursos. La combinación de desarrollo frontend y backend en un entorno de dominio público fue un desafío que nos preparó mejor para proyectos futuros.</p><p>Finalmente, este proyecto destacó la importancia de la planificación y la iteración constante en el desarrollo de software, permitiéndonos alcanzar nuestros objetivos de manera efectiva y eficiente.</p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/pp-chatbot"
    },
    {
      "id": "sakura-game",
      "title": "Juego: Sakura Ikebana Delivery",
      "media": [
        {
          "type": "video",
          "src": "video/sakura-game.mp4",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Eclipse",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Java",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        },
        {
          "name": "Photoshop",
          "icon": "bi-brush"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "Sakura Haruno junto a su amiga de la infancia Ino Yamanaka, tienen un negocio de arreglos florales típicos japoneses (ikebana). Ino se encarga de preparar los arreglos florales, y Sakura se encarga del delivery de los mismos. La complicación del trabajo de Sakura es que debe entregar los pedidos evitando y combatiendo a los ninjas enemigos. El objetivo de este trabajo practico es desarrollar un video juego en el cual Sakura entregue los pedidos sin perder la vida a manos de los ninjas enemigos."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Al iniciar el juego, Sakura debe aparecer aproximadamente en el centro de la pantalla.</li><li class=\"list-group-item\">Sakura solo puede moverse por las calles de la ciudad, Tampoco puede salirse de los límites de la pantalla.</li><li class=\"list-group-item\">Si se presionan las flechas direccionales (izquierda, abajo, arriba, derecha) Sakura debe moverse en la dirección correspondiente.</li><li class=\"list-group-item\">En pantalla deberá verse una ciudad/aldea, con una grilla de calles. La cantidad de calles es a criterio de cada grupo, aunque como mínimo deben ser tres horizontales y mínimo tres calles verticales. Además, deben verse dos o tres casas por manzana.</li><li class=\"list-group-item\">Durante el juego, Sakura debe entregar un pedido (un ramo de flores o ikebana) en una casa determinada aleatoriamente. Una vez entregado, se genera el siguiente pedido nuevamente para una casa determinada aleatoriamente. La casa donde Sakura debe entregar el pedido deberá estar marcada con una flecha. Cuando Sakura pasa caminando por enfrente de la casa marcada, se considera el pedido entregado y se cuenta como una entrega hecha. Al realizar la entrega la casa deberá dejar de estar marcada y deberá aparecer aleatoriamente otra casa marcada para realizar el siguiente pedido.</li><li class=\"list-group-item\">Cada ninja enemigo debe desplazarse únicamente por una única calle, y siempre en la misma dirección. La cantidad de ninjas enemigos queda a criterio de cada grupo, aunque como mínimo deben ser cuatro.</li><li class=\"list-group-item\">Si un ninja toca a Sakura perdemos el juego.</li><li class=\"list-group-item\">El gran maestro Gama-Sennin le enseno a Sakura su técnica secreta, el Rasengan. Cuando Sakura se ve acorralada por ninjas enemigos, puede usar el Rasengan para eliminar a los ninjas que se cruzan por su camino.</li><li class=\"list-group-item\">Cuando Sakura haya eliminado algún ninja, luego de determinada cantidad de tiempo, a criterio de cada grupo, deben aparecer nuevos ninjas. Siempre hay que respetar la cantidad mínima de cuatro ninjas en el juego.</li><li class=\"list-group-item\">Durante todo el juego deberán mostrarse los siguientes datos en pantalla. Deberá mostrarse en la esquina superior derecha de la pantalla el puntaje acumulando. Para calcular el puntaje, por cada pedido entregado se debe incrementar el puntaje en 5 puntos. Además, deberá mostrarse en la esquina superior izquierda de la pantalla, la cantidad de ninjas eliminados.</li><li class=\"list-group-item\">El código del proyecto deberá tener un buen diseño de modo que cada objeto tenga bien delimitadas sus responsabilidades.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>Este proyecto se desarrolló en equipo, conformado por tres integrantes, cada uno con responsabilidades específicas. Mi rol principal fue la implementación gráfica y la conceptualización general del manejo del juego.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Implementación Gráfica y Conceptualización del Juego:</strong> Desarrollé la interfaz gráfica del juego y definí la dinámica general del mismo.</p><p><strong>2. Uso de Librerías:</strong> Siguiendo las indicaciones de los profesores, utilizamos una librería creada por la facultad, similar a Pygame, para el desarrollo del juego.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Diagramación de las Calles y Manzanas del Pueblo:</strong></p><p><strong>Desafío:</strong> La primera complicación fue la diagramación de las calles y las manzanas del pueblo o ciudad donde se ejecutaba el juego.</p><p><strong>Solución:</strong> Utilicé mis conocimientos en Photoshop para maquetar detalladamente el pueblo y sus calles. Posteriormente, esta información se utilizó para crear una base de datos que sirvió como referencia para la navegación del personaje y sus enemigos.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Separación de Roles y Responsabilidades:</strong> Aunque aún no habíamos estudiado la teoría de la Programación Orientada a Objetos (POO), aprendimos a dividir y gestionar las responsabilidades de las clases de manera efectiva.</p><p><strong>Uso de Git: </strong> Tuvimos nuestra primera experiencia con Git, lo que nos permitió mantener el código actualizado y colaborar eficientemente.</p><p><strong>Duración del Proyecto:</strong> El tiempo asignado para completar este proyecto fue de aproximadamente 20 días.</p><p><strong>Resultados y Conclusiones:</strong></p><p><em>Este proyecto no solo nos permitió adquirir habilidades técnicas, como el uso de herramientas gráficas y la gestión de versiones con Git, sino también mejorar nuestra capacidad para trabajar en equipo y dividir responsabilidades. La implementación gráfica y la planificación detallada del entorno de juego fueron fundamentales para el éxito del proyecto.</em></p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/tpprogra1"
    },
    {
      "id": "voting-system",
      "title": "Sistema de Votacion",
      "media": [
        {
          "type": "image",
          "src": "img/index/UltimoDiagrama-sistema-de-votacion.jpg",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Eclipse",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Java",
          "icon": "bi-filetype-java"
        },
        {
          "name": "JUnit",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "La UNGS va a ser sede de votación para las próximas elecciones de noviembre, y el gobierno nacional le pidió a la Universidad que gestione la asignación de turnos. Por este motivo, la UNGS solicita a los alumnos de Programación II que diseñen este sistema de votación."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Este Trabajo Práctico consta de dos etapas. La primera requerirá la entrega del análisis del problema y el diseño de la solución propuesta, o sea la especificación de los TADs necesarios, diagrama de clases y la interfaz de la solución. En la segunda etapa se deberá entregar la implementación, cuyas condiciones de entrega se darán posteriormente en un segundo enunciado. El diseño se hará utilizando los conceptos de programación orientada a objetos, que incluyen herencia y polimorfismo.</li><li class=\"list-group-item\">Se deben realizar las correcciones del diseño de la 1ra parte antes de comenzar la 2da.</li><li class=\"list-group-item\"><p>Se debe hacer el diseño de la estructura de datos y el invariante de representación (IREP) que soporte el diseño.</p><p>El IREP tiene que considerar la consistencia interna, o sea, cómo se relacionan entre sí las estructuras de datos de los TADs diseñados. Por ejemplo, cómo se relaciona el registro de los votantes con y sin turnos, los votantes que se presentaron a votar o no lo hicieron, o las capacidades de las mesas de cada tipo con los votantes que se asignaron a esas mesas y otras relaciones que surgen de la implementación realizada.</p></li><li class=\"list-group-item\">Se debe hacer la implementación, la cual debe respetar la interfaz que se entrega con este enunciado y cumplir satisfactoriamente el junit otorgado por la cátedra.</li><li class=\"list-group-item\">Se deben utilizar al menos 2 tecnologías java: (StringBuilder, For each, Iteradores), además de Junit en sí, en alguna parte del TP.</li><li class=\"list-group-item\">Se debe implementar(sobreescribir) el toString de las clases principales. Como mínimo se debe mostrar un título (Sistema de Turnos para Votación - UNGS), los votantes en espera para un turno, los votantes con turnos asignados mostrando sus respectivos turnos (número de mesa y franja horaria) y si votó o no. Las mesas habilitadas en el Sistema, mostrar de qué clase son y el nombre de su presidente.</li><li class=\"list-group-item\">Se debe implementar(sobreescribir) el equals de Mesa y sus clases derivadas.</li><li class=\"list-group-item\">Se quiere conocer lo más rápido posible el turno de un votante dado su DNI.</li><li class=\"list-group-item\"><p>Se simplifica la asignación de turnos en caso de tener más de una característica:</p><p>Si es trabajador, solo puede votar en una mesa para trabajadores</p><p>Si es mayor con enfermedad preexistente, se asigna la primera mesa que tenga lugar disponible, pudiendo ser una mesa para mayores o para quienes padecen enfermedades.</p><p>Dada una mesa se quiere conocer los votantes asignados por franja horaria.</p></li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>Prácticamente a la semana de entregado el proyecto ya corrían todos los test unitarios, la solución e implementación en casi su totalidad fue realizada por mí, aunque trabajaba en grupo con mi compañera asignada.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Implementación y Solución del Proyecto:</strong> Desarrollé la mayor parte del proyecto y aseguré que todos los test unitarios se ejecutaran correctamente.</p><p><strong>2. Comunicación y Resolución de Errores:</strong> Detecté errores en el test unitario proporcionado por la cátedra y me comuniqué rápidamente con mis profesores para que lo solucionaran, evitando que otros grupos continuaran con errores.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Gestión de Errores en los Test Unitarios:</strong></p><p><strong>Desafío:</strong> Encontré errores en los test unitarios proporcionados por la cátedra, que podrían haber pasado desapercibidos para otros grupos.</p><p><strong>Solución:</strong> Notifiqué a mis profesores sobre los errores para que fueran corregidos, asegurando la precisión de las pruebas para todos los grupos.</p><p><strong>Resultados y Conclusiones:</strong></p><p><em>Este proyecto no solo me permitió fortalecer mis habilidades técnicas, sino también mejorar mi capacidad para detectar y resolver errores, comunicarme efectivamente con los profesores. La implementación exitosa y el trabajo en equipo fueron claves para aprobar el proyecto.</em></p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/figueroa-moras-tp-p2"
    },
    {
      "id": "wordle-game",
      "title": "Juego: Wordle",
      "media": [
        {
          "type": "video",
          "src": "https://gitlab.com/spectrelonewolf/programacion-3-tps-y-practicas/-/raw/main/Trabajo%20Practico%20N1/WORDLE%20TEST.mp4?ref_type=heads",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Eclipse",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Java",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "El trabajo consiste en recrear la lógica del juego Wordle, donde el jugador debe adivinar una palabra secreta en seis intentos, y presentarlo en una interfaz gráfica con la que el usuario pueda interactuar."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Cuando el usuario ingresa una palabra se le mostrara la siguiente información; las letras que coincidan con el mismo lugar de la palabra secreta se mostraran en verde, las que existen, pero no están en la posición correcta, se mostraran en naranja, y las letras que no existen en la palabra secreta se marcaran con gris.</li><li class=\"list-group-item\"><p>El trabajo tiene como objetivos opcionales:</p><p>Proponer varios niveles de dificultad, que consistan por ejemplo en palabras más difíciles o bien una menor cantidad de intentos.</p><p>Permitir que el idioma de la aplicación sea configurable.</p><p>Medir el tiempo que tarda el usuario en adivinar la palabra, y mostrar el mejor tiempo hasta el momento.</p></li><li class=\"list-group-item\">Se espera que el codigo de la logica del juego este separada de la interfaz.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>En esta materia se estudió arquitectura de diseño de software. Se pidió implementar el patrón MVC, el cual cumplimos sin correcciones por parte de los profesores.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Implementación del Patrón MVC:</strong> Diseñamos y desarrollamos el proyecto siguiendo el patrón MVC, asegurando una clara separación de responsabilidades.</p><p><strong>2. Coordinación en Equipo:</strong> Trabajé con dos integrantes más, manteniendo una coordinación eficiente y cumpliendo con todas las fechas de entrega.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Implementación de Funcionalidades Opcionales:</strong></p><p><strong>Desafío:</strong> Incluir todas las funcionalidades opcionales requeridas.</p><p><strong>Solución:</strong> Coordinamos eficientemente y distribuimos las tareas para asegurarnos de que todas las funcionalidades fueran implementadas correctamente.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Diseño de Software:</strong> Profundicé en conceptos de arquitectura de diseño de software y en la implementación del patrón MVC.</p><p><strong>Trabajo en Equipo:</strong> Aprendí a coordinar y colaborar efectivamente en equipo, cumpliendo con todas las fechas de entrega.</p><p><strong>Resultados y Conclusiones:</strong></p><p><em>Este proyecto no solo nos permitió aplicar el patrón MVC y mejorar nuestras habilidades en arquitectura de software, sino también desarrollar una excelente coordinación de equipo, logrando completar el proyecto con todas las funcionalidades opcionales incluidas.</em></p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/programacion-3-tps-y-practicas/-/tree/main/Trabajo%20Practico%20N1?ref_type=heads"
    },
    {
      "id": "ahorcado-ejecuciones",
      "title": "Juego: Ahorcado Ejecuciones",
      "media": [
        {
          "type": "video",
          "src": "video/Ahorcado-demo_1.mp4",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Construct 2",
          "icon": "bi-controller"
        },
        {
          "name": "Photoshop",
          "icon": "bi-brush"
        },
        {
          "name": "Sketch Book",
          "icon": "bi-palette"
        },
        {
          "name": "Spriter",
          "icon": "bi-image"
        },
        {
          "name": "Wacom",
          "icon": "bi-pencil"
        }
      ],
      "sections": [
        {
          "title": "Introducción",
          "content": "Desarrollado en el año 2017, mediante un motor de juegos llamado Construct 2, en conjunto con Photoshop, Sketch Book y Spriter. Demoré alrededor de un año en realizarlo ya que era algo paralelo a mi trabajo full time. Todo contenido fue comprado y se pagaron las licencias, sea música, personajes, interfaz de usuario. Los escenarios y ciertas cosas puntuales, como la modificación de los personajes cuando están muertos, expresiones y animaciones, fueron realizados por mi persona."
        },
        {
          "title": "Estado del Proyecto",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\"><strong>Nunca se terminó:</strong> El equipo que tenía en ese momento (computadora) se quemó y dejé el proyecto de lado para dedicarme a hacer otras cosas.</li><li class=\"list-group-item\"><strong>Errores detectados:</strong> El juego ya había sido publicado en PlayStore de Android y el Store de Windows en fase alfa. Se detectaron errores de ortografía en la base de datos de pistas y palabras, faltaba un botón de cierre del juego y un botón de juego rápido.</li></ul>"
        },
        {
          "title": "Descripción del Juego",
          "content": "<ul><li>Versión GRATIS del juego clásico de acertijos de palabras del Ahorcado con ejecuciones animadas.</li><li>Juego tradicional del Ahorcado en una versión totalmente animada con gráficos HD y variedad de ambientaciones y métodos de ejecución.</li><li>Reglas clásicas: 6 vidas para adivinar la palabra, sistema de pistas y ayudas.</li><li>Personalización: 12 categorías de palabras, ajustes de dificultad, diferentes personajes y escenarios.</li><li>Cada partida finalizada muestra la palabra a adivinar y su significado.</li><li>Características principales: Animaciones y gráficos HD, sistema de premios, diferentes formas de ejecución según el escenario.</li></ul>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/ahorcado-ejecuciones",
      "externalLink": {
        "text": "Descargar en Microsoft Store",
        "url": "https://www.microsoft.com/store/apps/9NBLGGH40K85"
      }
    },
    {
      "id": "clustering-system",
      "title": "Sistema de Clustering con AGM",
      "media": [
        {
          "type": "video",
          "src": "https://gitlab.com/spectrelonewolf/programacion-3-tps-y-practicas/-/raw/main/Trabajo%20Practico%20N2/CLUSTER%20GENERATOR%20TEST.mp4?ref_type=heads",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Eclipse",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Java",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "El objetivo de este trabajo es desarrollar una aplicación que realice clustering utilizando el algoritmo propuesto por Charles Zahn en su libro 'IEEE Transactions on Computers'. La aplicación debe:<ul><li>Calcular un árbol generador mínimo de un grafo completo formado por un conjunto de puntos en el plano, con pesos en las aristas iguales a la distancia entre los vértices.</li><li>Eliminar del árbol las aristas cuyos pesos sean mayores que los pesos de sus aristas vecinas, repitiendo este paso hasta obtener una cantidad predeterminada de clústeres o hasta que no haya aristas con peso significativamente distinto de sus aristas vecinas.</li></ul>"
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Implementar una interfaz gráfica que permita mostrar los puntos de la instancia y ejecutar el algoritmo de Charles Zahn.</li><li class=\"list-group-item\">Visualizar el resultado del algoritmo en la interfaz gráfica.</li><li class=\"list-group-item\"><p>Objetivos opcionales:</p><p>Incluir diferentes criterios para determinar si una arista tiene un peso significativamente mayor que sus aristas vecinas, permitiendo seleccionar el criterio desde la interfaz.</p><p>Mostrar estadísticas de la solución, tales como la cantidad de clústeres, el peso de cada clúster, y la desviación estándar.</p><p>Guardar la solución en un archivo y permitir la recuperación de soluciones guardadas.</p><p>Permitir la edición manual de la solución desde la interfaz.</p></li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>En este trabajo, además de cumplir con el requerimiento principal sumado a los agregados propuestos, menos la edicion manual, se debía mantener el patrón de diseño MVC. También se estudiaron varias teorías respecto al análisis de clusters dentro de un grafo.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Implementación del Patrón MVC:</strong> Diseñamos y desarrollamos el proyecto siguiendo el patrón MVC, asegurando una clara separación de responsabilidades.</p><p><strong>2. Análisis de Clusters:</strong> Implementamos un análisis de clusters en un entorno complejo, llegando a descubrir y eliminar el llamado \"puente\" dentro del grafo.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Identificación del \"Puente\":</strong></p><p><strong>Desafío:</strong> Identificar y eliminar el \"puente\", un elemento difícil de descubrir con algoritmos simples que eliminan las aristas más largas del grafo.</p><p><strong>Solución:</strong> Implementamos un análisis detallado y eficiente que permitió identificar y eliminar el \"puente\", incluso en casos donde todos los nodos tenían la misma distancia.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Arquitectura de Software:</strong> Profundizamos en conceptos de arquitectura de diseño de software y en la implementación del patrón MVC.</p><p><strong>Análisis de Clusters:</strong> Aprendimos a aplicar técnicas avanzadas de análisis de clusters en grafos complejos.</p><p><strong>Resultados y Conclusiones:</strong></p><p><em>Este proyecto no solo nos permitió aplicar el patrón MVC y mejorar nuestras habilidades en arquitectura de software, sino también implementar un análisis avanzado de clusters, logrando descubrir y eliminar el \"puente\" en un grafo complejo, algo que otros equipos no lograron.</em></p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/programacion-3-tps-y-practicas/-/tree/main/Trabajo%20Practico%20N2?ref_type=heads"
    },
    {
      "id": "sticker-album-simulator",
      "title": "Simulador: Album de Figuritas con Threads",
      "media": [
        {
          "type": "video",
          "src": "https://gitlab.com/spectrelonewolf/programacion-3-tps-y-practicas/-/raw/main/Trabajo%20Practico%20N3/SIMULADOR%20TEST.mp4?ref_type=heads",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Eclipse",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Java",
          "icon": "bi-filetype-java"
        },
        {
          "name": "JUnit",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        },
        {
          "name": "Photoshop",
          "icon": "bi-brush"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "El objetivo de este trabajo es implementar una aplicación que simule uno o varios usuarios completando el álbum de figuritas del mundial de Qatar 2022, contemplando los siguientes escenarios:<ul><li>Un usuario completa un álbum por su cuenta comprando paquetes de figuritas hasta llenarlo por completo.</li><li>Varios usuarios completan el álbum mientras se donan las repetidas que les tocan.</li><li>Varios usuarios completan el álbum mientras se intercambian figuritas una por una.</li></ul>"
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Implementar una interfaz gráfica con elementos para seleccionar la cantidad de figuritas en total, la cantidad de figuritas en cada paquete, la cantidad de simulaciones y el escenario seleccionado.</li><li class=\"list-group-item\">Informar el resultado de las simulaciones en la interfaz gráfica.</li><li class=\"list-group-item\"><p>Objetivos opcionales:</p><p>Mostrar en un gráfico el resultado promedio en función de la cantidad de simulaciones realizadas.</p><p>Considerar la existencia de una o varias figuritas difíciles o raras, que tengan menos chances de aparecer que el resto.</p><p>Considerar un escenario donde las figuritas difíciles se cambian por más de una figurita normal.</p></li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>En este trabajo, además de cumplir con el requerimiento principal y los objetivos opcionales, se debía mantener el patrón de diseño MVC. Se trabajó en equipo, con un compañero, y se hizo uso eficiente de threads. Además, diseñé la parte gráfica de la interfaz para que fuera atractiva y no simple, y también desarrollé la solución de código en la mayoría de las partes del proyecto.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Implementación del Patrón MVC:</strong> Diseñamos y desarrollamos el proyecto siguiendo el patrón MVC, asegurando una clara separación de responsabilidades.</p><p><strong>2. Uso Eficiente de Threads:</strong> Implementamos la solución de manera que utilizara threads de forma eficiente, mejorando el rendimiento de la aplicación.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Diseño de la Interfaz Gráfica:</strong></p><p><strong>Desafío:</strong> Crear una interfaz gráfica atractiva y funcional.</p><p><strong>Solución:</strong> Diseñé una interfaz gráfica que no fuera simple, asegurando una buena experiencia de usuario.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Arquitectura de Software:</strong> Profundizamos en conceptos de arquitectura de diseño de software y en la implementación del patrón MVC.</p><p><strong>Optimización con Threads:</strong> Aprendimos a utilizar threads de manera eficiente para mejorar el rendimiento de la aplicación.</p><p><strong>Resultados y Conclusiones:</strong></p><p><em>Este proyecto no solo nos permitió aplicar el patrón MVC y mejorar nuestras habilidades en arquitectura de software, sino también diseñar una interfaz gráfica atractiva y utilizar threads de manera eficiente, logrando una aplicación funcional y bien optimizada.</em></p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/programacion-3-tps-y-practicas/-/tree/main/Trabajo%20Practico%20N3?ref_type=heads"
    },
    {
      "id": "postgresql-system",
      "title": "Sistema de Gestión de Pedidos",
      "media": [
        {
          "type": "image",
          "src": "https://gitlab.com/spectrelonewolf/ibarra-galeano-gaona-moras-db1/-/raw/main/db-posgresql-tp.png",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "GOlang",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "PostgreSQL",
          "icon": "bi-database"
        },
        {
          "name": "BoltDB",
          "icon": "bi-filetype-json"
        },
        {
          "name": "Alpine",
          "icon": "bi-code-slash"
        },
        {
          "name": "Git",
          "icon": "bi-terminal-fill"
        }
      ],
      "sections": [
        {
          "title": "Introducción",
          "content": "Este trabajo práctico modelamos un sistema para gestionar ingreso, cancelación y entrega de pedidos. Prioriza la integridad de la información de clientes y productos, enfocándose en mantener un stock preciso para evitar errores en pedidos y asegurar entregas completas. El sistema notifica a los clientes sobre eventos relevantes por correo electrónico tales como cuando el pedido se cerró, si se canceló, cuando recibió su compra y anticipa la reposición de productos con bajo stock."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">El sistema debe administrar el ingreso, la cancelación, y la entrega de pedidos, mantener toda la información de los clientes y de los productos, y controlar que el stock disponible y el reservado de los productos sea actualizado correctamente—e.g. no puede agregarse a los pedidos una cantidad mayor a la disponible, el proceso de entrega del pedido no puede quedar a medio hacer, etc.</li><li class=\"list-group-item\">Los clientes deben ser informados vía email cuando ocurran eventos importantes sobre sus pedidos. Además, es necesario poder generar solicitudes de reposición para aquellos productos que hayan quedado con bajo stock.</li><li class=\"list-group-item\">Se deberán cargar 20 clientes y 20 productos. Todos los clientes tendrán una dirección de entrega, excepto dos clientes que tendrán dos direcciones cada uno. La tabla tarifa_entrega deberá tener los códigos postales de todos los clientes, excepto para tres de las direcciones.</li><li class=\"list-group-item\">Los datos de los clientes, de sus direcciones de entrega, de los productos, de las tarifas de entrega, así como los datos de entrada para las transacciones de prueba, deberán cargarse en las tablas correspondientes a partir de sus respectivos documentos JSON.</li><li class=\"list-group-item\"><p><strong>Creación del pedido:</strong> Se deberá incluir la lógica que reciba los datos del pedido — id de usuario, id de dirección — y que devuelva true si se logra crear el pedido, ó false si se rechaza. El procedimiento deberá validar los siguientes elementos antes de confirmar el alta:</p><ul><li>Que el id de usuario exista. En caso de que no cumpla, se debe cargar un error con el mensaje “id de usuario no válido”.</li><li>Que el id de la dirección de entrega exista para el cliente. En caso de que no cumpla, se debe cargar un error con el mensaje “id de dirección no válido”.</li><li>Que el código postal de la dirección de entrega tenga una tarifa establecida. En caso de que no cumpla, se debe cargar un error con el mensaje “dirección de entrega fuera del área de atención”.</li></ul><p>Si se aprueba la creación del pedido, se deberá insertar una fila en la tabla pedido con los datos del cliente, la fecha y hora del pedido, y el costo de envío correspondiente al código postal, dejando su estado como ingresado.</p></li><li class=\"list-group-item\"><p><strong>Agregado de producto:</strong> Se deberá incluir la lógica que reciba un id de pedido, un id de producto y una cantidad, y añada la información al pedido. Retornará true si la operación se realiza satisfactoriamente, ó false en caso contrario. El procedimiento deberá validar los siguientes elementos antes de incorporar el ítem al pedido:</p><ul><li>Que el id de pedido exista. En caso de que no cumpla, se debe cargar un error con el mensaje “id de pedido no válido”.</li><li>Que el pedido se encuentre en estado ingresado. En caso de que no cumpla, se debe cargar un error con el mensaje “pedido cerrado”.</li><li>Que el id de producto exista. En caso de que no cumpla, se debe cargar un error con el mensaje “id de producto no válido”.</li><li>Que el producto tenga stock disponible para satisfacer la cantidad solicitada al momento de realizar el pedido. En caso de que no se cumpla, se debe cargar un nuevo error con el mensaje “stock no disponible para el producto 'id_producto'”.</li></ul><p>Si se aprueba la incorporación, se deberá insertar una fila en la tabla pedido_detalle con los datos del producto. Si el pedido ya contiene al producto, se deberá actualizar la fila correspondiente, sumando la nueva cantidad.</p></li><li class=\"list-group-item\"><p><strong>Cierre del pedido:</strong> Se deberá proveer la lógica que reciba un id de pedido, la fecha y hora de entrega, y que devuelva true si se logra cerrar el pedido ó false en caso contrario. El procedimiento deberá validar los siguientes elementos antes de confirmar el cierre:</p><ul><li>Que el id de pedido exista. En caso de que no cumpla, se debe cargar un error con el mensaje “id de pedido no válido”.</li><li>Que el pedido tenga al menos un producto agregado. En caso de que no cumpla, se debe cargar un error con el mensaje “pedido vacío”.</li><li>Que la fecha y hora de entrega sea posterior a la fecha y hora actual. En caso de que no cumpla, se debe cargar un error con el mensaje “fecha de entrega no válida”.</li></ul><p>Si se aprueba el cierre, se deberá actualizar la fila correspondiente en la tabla pedido con la fecha de entrega, y las horas de entrega desde y hasta, dejando su estado como completado. Calcular la hora hasta como dos horas posterior a la hora desde.</p></li><li class=\"list-group-item\"><p><strong>Cancelación de pedido:</strong> Se deberá proveer la lógica que permita cancelar un pedido. El procedimiento debe recibir el id de pedido, y retornar true si se logra cancelar el pedido ó false en caso contrario. El procedimiento deberá validar los siguientes elementos antes de confirmar la cancelación:</p><ul><li>Que el id de pedido exista. En caso de que no cumpla, se debe cargar un error con el mensaje “id de pedido no válido”.</li><li>Que el pedido se encuentre en estado ingresado o completado. En caso de que no cumpla, se debe cargar un error con el mensaje “pedido ya entregado o cancelado”.</li></ul><p>Si las validaciones pasan correctamente, se deberá marcar el estado del pedido como cancelado. Además, deberá sumarse al stock disponible de cada producto la cantidad incluida en el pedido cancelado, y descontarla del stock reservado.</p></li><li class=\"list-group-item\"><p><strong>Entrega de pedido:</strong> Se deberá proveer la lógica que reciba un id de pedido, y que retorne true si se logra marcar el pedido como entregado ó false en caso contrario. El procedimiento deberá validar los siguientes elementos antes de confirmar la entrega:</p><ul><li>Que el id de pedido exista. En caso de que no cumpla, se debe cargar un error con el mensaje “id de pedido no válido”.</li><li>Que el pedido se encuentre en estado completado. En caso de que no cumpla, se debe cargar un error con el mensaje “pedido no cerrado”.</li></ul><p>Si se aprueba la entrega, se deberá marcar el estado del pedido como entregado, y restar del stock reservado las cantidades de productos del pedido.</p></li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>Un trabajo el cual involucró el lenguaje y librerías GOlang, PostgreSQL, BoltDB y usamos sistema Alpine. Se implementó todo en tiempo y forma, teníamos distribución equitativa de las tareas y como yo finalicé mis tareas me dediqué a realizar una herramienta de test unitarios por consola, para verificar las queries, cargándole datos, etc.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Implementación de GOlang y PostgreSQL:</strong> Diseñamos y desarrollamos el proyecto utilizando GOlang y PostgreSQL, asegurando una clara integración y funcionalidad.</p><p><strong>2. Desarrollo de Herramienta de Test Unitarios:</strong> Creé una herramienta de test unitarios por consola para verificar las queries, cargando datos y asegurando su correcto funcionamiento.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Implementación de BoltDB y Alpine:</strong></p><p><strong>Desafío:</strong> Integrar BoltDB y configurar el sistema Alpine de manera eficiente.</p><p><strong>Solución:</strong> Implementamos BoltDB y configuramos Alpine asegurando un rendimiento óptimo y una configuración estable.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Integración de Tecnologías:</strong> Profundizamos en la integración de tecnologías como GOlang, PostgreSQL, BoltDB y Alpine, mejorando nuestras habilidades en el desarrollo de software.</p><p><strong>Desarrollo de Herramientas de Test:</strong> Aprendimos a desarrollar herramientas de test unitarios por consola, mejorando la calidad y fiabilidad de nuestras aplicaciones.</p><p><strong>Resultados y Conclusiones:</strong></p><p><em>Este proyecto no solo nos permitió aplicar y mejorar nuestras habilidades en GOlang y PostgreSQL, sino también desarrollar herramientas de test unitarios y optimizar el uso de BoltDB y Alpine, logrando una aplicación funcional y bien optimizada.</em></p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/ibarra-galeano-gaona-moras-db1"
    },
    {
      "id": "ungs-network",
      "title": "Diseño de Red en la UNGS",
      "media": [
        {
          "type": "image",
          "src": "https://gitlab.com/spectrelonewolf/franco-matias-ale-tp-sor/-/raw/master/diagramapt.png?ref_type=heads&inline=false",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Cisco Packet Tracer",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Command Prompt",
          "icon": "bi-code-slash"
        },
        {
          "name": "Git",
          "icon": "bi-terminal-fill"
        }
      ],
      "sections": [
        {
          "title": "Introduccion",
          "content": "En el año 2022, en la UNGS comenzará la construcción del Módulo 10, este nuevo edificio tendrá 4 pisos, y se prevén instalar 16 laboratorios, más una sala de servidores donde se alojará el cluster ColosUngs compuesto por 1024 Raspberry Pi. La Dirección General de Sistemas y Tecnologías de la Información (DGSyTI) de la UNGS convocó durante el primer semestre del 2021 a una licitación para diseñar e instalar la red de este nuevo módulo, en donde también participaron los alumnos de la carrera de Sistemas que estén cursando la materia Sistemas Operativos y Redes. Tu equipo fue seleccionado como ganador de esta convocatoria, para lo cual se les asignó un presupuesto de U$S 10.000.-. Este diseño se tiene que llevar a cabo antes que finalice la pandemia. La decana del ICI convocó a tu equipo a una entrevista para interiorizarlos en los detalles del diseño: La Dirección de Redes y Comunicaciones le asignó al nuevo módulo la dirección la red IP 10.0.0.0. En el Módulo 10, habrá 4 laboratorios por piso con 30 computadoras en cada uno. La sala de servidores se encuentra en el primer piso. Este tiene 4 servidores y el cluster ColosUngs, el cual solo consume una dirección IP. Por cada piso hay 3 oficinas administrativas con 5 computadoras en cada una. Se les solicita que la red se divida en administrativa y académica, no permitiendo el tráfico entre ellas, ni tampoco entre los laboratorios. Además, por cada piso se necesita una red WiFi de uso no académico, a la cual se puede conectar cualquier dispositivo. Cinco laboratorios del Módulo 7 pasarán a ser utilizados solo por los estudiantes de la carrera de Sistemas, por lo cual estos estarán en la misma red del Módulo 10."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Utilizar un direccionamiento privado de la clase que más se ajuste a la cantidad de nodos.</li><li class=\"list-group-item\">Utilizar VLSM, para evitar la propagación innecesaria de tráfico.</li><li class=\"list-group-item\">Utilizar VLANs para separar el tráfico de red.</li><li class=\"list-group-item\">El Módulo 7 tiene un solo router que se conecta con el router del Módulo 10.</li><li class=\"list-group-item\">Deberá existir un solo switch troncal por cada piso.</li><li class=\"list-group-item\">Habilitar en toda la red el protocolo de enrutamiento RIP versión 2.</li><li class=\"list-group-item\">Crear un servidor DNS que resuelva el dominio colos.ungs.edu.ar desde todas las computadoras, para que toda la comunidad pueda acceder al cluster ColosUngs.</li><li class=\"list-group-item\">El diseño de la red hecho en Packet Tracer debe funcionar íntegramente.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<ul><li>Problema de arrastre: El principal desafío en la implementación inicial fue la detección de un error de arrastre en las direcciones IP, particularmente visible a partir de la subred número 11. Esto causó que solo los laboratorios funcionaran correctamente en el primer piso, mientras que las otras redes no respondían al ping.</li><li>Observación de la consigna: Al revisar el PDF después de la implementación, descubrimos que el módulo 7 requería un router en la salida. Inicialmente, habíamos conectado directamente al switch troncal de troncales, pero al agregar otro router, implementamos el protocolo RIP v2 para resolver los problemas de conectividad entre redes.</li><li>Cantidad de puertos de los Routers: El modelo recomendado tenía limitaciones en cuanto a la cantidad de puertos, lo que nos obligó a crear un switch llamado \"troncal de troncales\". Este switch fue configurado en modo trunk en todos sus puertos, ya que ninguno de los módulos adicionales era compatible con el sistema VLAN.</li></ul><ul><li>Resultados y Conclusiones:<ul><li>Conclusión del proyecto: La instalación y diseño de esta red han servido como una valiosa práctica para futuras implementaciones en entornos laborales, especialmente en el uso de diferentes capas de red.</li><li>Formación en VLANs y Subnetting: La experiencia nos permitió profundizar en la lógica de las VLANs y el subnetting, aplicándolo a la asignación de IPs en módulos, pisos, laboratorios y aulas.</li><li>Uso de PacketTracer y Hardware: Utilizamos PacketTracer para simular y verificar las conexiones, además de familiarizarnos con el manejo de hardware como switches, routers y cables de conexión.</li><li>Capa de Aplicación y Servidor DNS: Exploramos la configuración detallada de la capa de aplicación, incluyendo la creación y conexión de un servidor DNS para entender mejor su funcionamiento.</li><li>Colaboración y Gestión de Proyectos: Destacamos el uso efectivo de Git para mantener un ambiente colaborativo y ordenado durante todo el desarrollo del proyecto.</li></ul></li></ul>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/franco-matias-ale-tp-sor"
    },
    {
      "id": "hotel-reservation",
      "title": "Web: Hotelia \"Reserva de Hoteles\"",
      "media": [
        {
          "type": "image",
          "src": "https://gitlab.com/spectrelonewolf/tp-evs-hoteles/-/raw/main/imagenes_del_pdf/pagina_principal.png?ref_type=heads&inline=false",
          "active": true
        },
        {
          "type": "image",
          "src": "https://gitlab.com/spectrelonewolf/tp-evs-hoteles/-/raw/main/imagenes_del_pdf/pagina_principal2.png?ref_type=heads&inline=false",
          "active": false
        },
        {
          "type": "image",
          "src": "https://gitlab.com/spectrelonewolf/tp-evs-hoteles/-/raw/main/imagenes_del_pdf/pagina_busqueda.png?ref_type=heads&inline=false",
          "active": false
        }
      ],
      "tools": [
        {
          "name": "Visual Studio Code",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "JavaScript",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Bootstrap",
          "icon": "bi-filetype-css"
        },
        {
          "name": "Git",
          "icon": "bi-git"
        },
        {
          "name": "Photoshop",
          "icon": "bi-brush"
        }
      ],
      "sections": [
        {
          "title": "Enunciado",
          "content": "El enunciado de este trabajo práctico consistió en la elaboración del documento FRD basado en una simulación Cliente/Agencia. Se simuló un cliente interesado en desarrollar una página web para la reserva de hoteles. Inicialmente, se llevó a cabo una simulación de entrevista para definir los primeros requerimientos. Posteriormente, en una segunda entrevista se refinaron estos requerimientos. Con esta información, se procedió a la creación de User Stories y la definición detallada de todos los requisitos. Se realizaron diversos diagramas y tablas de casos de prueba.<br /><br />Debido a limitaciones de tiempo para la presentación del prototipo, se optó por adaptar una página web de uso libre encontrada en internet, que cumplía con los requerimientos solicitados para el prototipo. Es importante destacar que este prototipo no representa la versión final, según requerimientos del profesor, pero sí incluye los requisitos no funcionales especificados."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">El documento FRD debe detallar los requisitos funcionales y no funcionales para la página web de reserva de hoteles.</li><li class=\"list-group-item\">Se deben incluir User Stories que describan las funcionalidades clave del sistema.</li><li class=\"list-group-item\">Se realizarán diagramas y tablas de casos de prueba para validar el correcto funcionamiento de la aplicación.</li><li class=\"list-group-item\">El prototipo deberá cumplir con los requisitos no funcionales definidos, aunque se utilice una página adaptada de uso libre para la demostración inicial.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<p>El desarrollo de este proyecto se llevó a cabo siguiendo la metodología ágil de Scrum. Se formó un equipo de trabajo que incluyó un Scrum Master, desarrolladores y testers. Cada sprint tuvo una duración de 15 días o menos, presentando avances periódicos del prototipo de la página web de reserva de hoteles.</p><p><strong>Responsabilidades y Tareas:</strong></p><p><strong>1. Definición de Requerimientos:</strong> A partir de las entrevistas simuladas con el cliente, se definieron los requisitos iniciales se refinaron en iteraciones posteriores.</p><p><strong>2. Creación de User Stories:</strong> Se detallaron todas las funcionalidades esperadas del sistema en forma de historias de usuario.</p><p><strong>3. Implementación y Validación:</strong> Se desarrollaron y validaron funcionalidades clave como la reserva de habitaciones, gestión de usuarios y seguridad de la información.</p><p><strong>4. Adaptación del Prototipo:</strong> Se adaptó una página web encontrada en internet para demostrar el cumplimiento de los requerimientos iniciales del proyecto.</p><p><strong>Desafíos y Soluciones:</strong></p><p><strong>1. Cumplimiento de Requisitos No Funcionales:</strong></p><p><strong>Desafío:</strong> Adaptar una página web existente para cumplir con los requisitos no funcionales especificados.</p><p><strong>Solución:</strong> Se implementaron ajustes y configuraciones para asegurar que el prototipo cumpla con los estándares de calidad y rendimiento esperados.</p><p><strong>Aprendizajes y Experiencias:</strong></p><p><strong>Entrega y Presentación:</strong> A pesar de las limitaciones de tiempo, se logró presentar un prototipo funcional que demostró el cumplimiento de los requisitos iniciales del cliente.</p>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/tp-evs-hoteles"
    },
    {
      "id": "hospital-larcade",
      "title": "Prototipo Web: Hosp. Larcade",
      "media": [
        {
          "type": "video",
          "src": "video/Hospital-Larcade.mp4",
          "active": true
        }
      ],
      "tools": [
        {
          "name": "Visual Studio Code",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Firebase CLI",
          "icon": "bi-code-slash"
        },
        {
          "name": "JavaScript",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Bootstrap",
          "icon": "bi-filetype-css"
        },
        {
          "name": "Git",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Photoshop",
          "icon": "bi-brush"
        }
      ],
      "sections": [
        {
          "title": "Introducción",
          "content": "En el año 2023, Un medico del hospital Larcade queria mejorar la atención de pacientes. Este proyecto incluyó el desarrollo de un sistema de monitoreo remoto de presión arterial, dirigido a facilitar la autogestión de salud por parte de los pacientes desde sus hogares. La iniciativa surgió ante la necesidad de optimizar los recursos hospitalarios y ofrecer una atención más personalizada y eficiente."
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Desarrollar una interfaz de usuario intuitiva y segura que permita el ingreso y monitoreo de datos de presión arterial de los pacientes.</li><li class=\"list-group-item\">Implementar un sistema de almacenamiento de datos seguro y confiable para proteger la información personal de los usuarios.</li><li class=\"list-group-item\">Integrar funcionalidades avanzadas de alerta y notificación para enviar avisos automáticos al personal médico en caso de emergencias o lecturas anómalas de presión.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<ul><li>Durante el desarrollo del proyecto, se inició con la creación de una plataforma web integral para el control de presión arterial de los pacientes del Hospital Larcade. La investigación inicial reveló la ausencia de una presencia digital adecuada para el hospital, lo que motivó la creación de un portal robusto que no solo gestionara las mediciones de presión, sino que también ofreciera una experiencia integrada con herramientas de administración para el personal médico.</li><li>El diseño y desarrollo del sitio web se realizó utilizando herramientas avanzadas como Photoshop e Illustrator para crear el logo del hospital y restaurar su imagen pública en línea. Se implementaron formularios con verificación de domicilio, y un mapa interactivo con marcador personalizado para mejorar la accesibilidad y funcionalidad del sitio.</li><li>El proyecto se extendió por un período de 2 meses y medio, con un enfoque meticuloso en la calidad y funcionalidad del producto final. Durante este tiempo, se enfrentaron desafíos logísticos y de tiempos de respuesta en la recopilación de información necesaria para su correcta implementación.</li></ul><ul><li>Resultados y Conclusiones:<ul><li>El proyecto demostró ser funcional en su diseno estatico. Sin embargo, quedó inconcluso en la fase final de desarrollo del panel de usuarios.</li><li>A pesar de los desafíos encontrados, el proyecto proporcionó valiosas lecciones sobre la integración de tecnologías emergentes como Firebase para el almacenamiento seguro de datos y el uso de APIs abiertas .</li></ul></li></ul>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/hospital-larcade/-/tree/main/sitio/public?ref_type=heads",
      "externalLink": {
        "text": "Prototipo del sitio: Hosp. Larcade",
        "url": "https://hosplarcade.web.app/index.html"
      }
    },
    {
      "id": "github-chatbot",
      "title": "Chatbot: GitHub Pages",
      "media": [
        {
          "type": "image",
          "src": "https://gitlab.com/spectrelonewolf/bot-githubpages/-/raw/main/recursos_md/logica_del_chatbot.png?ref_type=heads&inline=false",
          "active": true
        },
        {
          "type": "image",
          "src": "https://gitlab.com/spectrelonewolf/bot-githubpages/-/raw/main/recursos_md/python_click_web.png?ref_type=heads&inline=false",
          "active": false
        }
      ],
      "tools": [
        {
          "name": "Visual Studio Code",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Pythonanywhere",
          "icon": "bi-hdd-network-fill"
        },
        {
          "name": "Flask",
          "icon": "bi-hdd-network-fill"
        },
        {
          "name": "Python",
          "icon": "bi-code-slash"
        },
        {
          "name": "JavaScript",
          "icon": "bi-filetype-java"
        },
        {
          "name": "Bootstrap",
          "icon": "bi-filetype-css"
        },
        {
          "name": "Git",
          "icon": "bi-terminal-fill"
        },
        {
          "name": "Gimp",
          "icon": "bi-brush"
        }
      ],
      "sections": [
        {
          "title": "Introducción",
          "content": "<p>Este proyecto se enmarca en la necesidad de proporcionar a los usuarios una experiencia interactiva y amigable al interactuar con la página web. El chatbot estará alojado en el servicio PythonAnywhere y deberá ser capaz de interactuar de manera natural y efectiva con los visitantes del sitio.</p>"
        },
        {
          "title": "Requerimientos",
          "content": "<ul class=\"list-group list-group-flush\"><li class=\"list-group-item\">Se detallarán los procesos de investigación para seleccionar las mejores prácticas en el desarrollo de chatbots, así como el proceso de implementación técnica.</li><li class=\"list-group-item\">El chatbot solo responderá acerca de las aptitudes del representado.</li><li class=\"list-group-item\">Insertar atributos de calidad en lo posible.</li></ul>"
        },
        {
          "title": "Desarrollo",
          "content": "<ul><li>El desarrollo del chatbot se completó en aproximadamente 12 horas, abarcando desde la generación de sus archivos principales, su alojamiento en PythonAnywhere, hasta su integración dentro de la página principal, la cual es esta misma.</li><li>El principal desafío fue su alojamiento, ya que PythonAnywhere ofrece muy poco espacio en su plan gratuito. Para su correcta implementación, fue necesario realizar el proceso en dos etapas. En la primera instalación, se siguió un orden establecido, pero todas las instalaciones tuvieron que ser eliminadas porque no se pudo instalar la librería principal \"scikit-learn\". En la segunda instalación, esta librería fue la primera en ser instalada. El problema surgió con los archivos de caché, que ocupan memoria. Cambiando el orden de instalación (tal como se describe en su documentación) y eliminando la carpeta de caché después de cada paquete instalado, se solucionó el problema. Actualmente, el proyecto completo ocupa un 80% del espacio total disponible.</li><li>Otro problema durante el desarrollo fue un requisito autoimpuesto: la implementación de animaciones para un avatar que aparece como botón de inicio de conversación y dentro del panel de chat. Sin embargo, debido a limitaciones de hardware (una PC con pocas capacidades), no pude realizar las animaciones propuestas.</li><li>Se ha desarrollado una documentación completa que explica paso a paso cómo replicar el montaje de un bot en páginas web.</li><li>Un desafío que aún no me satisface completamente es el paquete de preguntas y respuestas del bot. Se han realizado mejoras y se han planteado formatos conversacionales, pero aún es posible mejorar este aspecto.</li></ul>"
        }
      ],
      "repository": "https://gitlab.com/spectrelonewolf/bot-githubpages",
      "externalLink": {
        "text": "Prueba del chatbot",
        "url": "https://spectrelw.pythonanywhere.com"
      }
    }
  ]
}